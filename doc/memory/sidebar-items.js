window.SIDEBAR_ITEMS = {"constant":[["DMA_FLAGS","Mapping flags that can be used to map DMA (Direct Memory Access) memory."],["MMIO_FLAGS","Mapping flags that can be used to map MMIO registers."],["PAGE_SIZE","Page size is 4096 bytes, 4KiB pages."],["PTE_FRAME_MASK","A mask for the bits of a page table entry that contain the physical frame address."]],"enum":[["MemoryRegionType","Types of physical memory. See each variant’s documentation."]],"fn":[["allocate_frames","Allocates the given number of frames with no constraints on the starting physical address."],["allocate_frames_at","Allocates the given number of frames starting at (inclusive of) the frame containing the given `PhysicalAddress`."],["allocate_frames_by_bytes","Allocates frames with no constraints on the starting physical address,  with a size given by the number of bytes. "],["allocate_frames_by_bytes_at","Allocates frames starting at the given `PhysicalAddress` with a size given in number of bytes. "],["allocate_pages","Allocates the given number of pages with no constraints on the starting virtual address."],["allocate_pages_at","Allocates the given number of pages starting at (inclusive of) the page containing the given `VirtualAddress`."],["allocate_pages_by_bytes","Allocates pages with no constraints on the starting virtual address,  with a size given by the number of bytes. "],["allocate_pages_by_bytes_at","Allocates pages starting at the given `VirtualAddress` with a size given in number of bytes. "],["create_contiguous_mapping","A convenience function that creates a new memory mapping by allocating frames that are contiguous in physical memory. If contiguous frames are not required, then see `create_mapping()`. Returns a tuple containing the new `MappedPages` and the starting PhysicalAddress of the first frame, which is a convenient way to get the physical address without walking the page tables."],["create_mapping","A convenience function that creates a new memory mapping. The pages allocated are contiguous in memory but there’s no guarantee that the frames they are mapped to are also contiguous in memory. If contiguous frames are required then see `create_contiguous_mapping()`. Returns the new `MappedPages.` "],["get_kernel_mmi_ref","Returns a reference to the kernel’s `MemoryManagementInfo`, if initialized. If not, it returns `None`."],["init","Initializes the virtual memory management system. Consumes the given BootInformation, because after the memory system is initialized, the original BootInformation will be unmapped and inaccessible."],["init_post_heap","Finishes initializing the memory management system after the heap is ready."],["map_frame_range","A convenience function that maps randomly-allocated pages to the given range of frames."],["set_broadcast_tlb_shootdown_cb","Set the function callback that will be invoked every time a TLB shootdown is necessary, i.e., during page table remapping and unmapping operations."],["translate","A convenience function to translate the given virtual address into a physical address using the currently-active page table."]],"struct":[["AllocatedFrames","Represents a range of allocated physical memory [`Frame`]s; derefs to [`FrameRange`]."],["AllocatedPages","Represents a range of allocated `VirtualAddress`es, specified in `Page`s. "],["BorrowedMappedPages","A borrowed [`MappedPages`] object that derefs to `&T` and optionally also `&mut T`."],["BorrowedSliceMappedPages","A borrowed [`MappedPages`] object that derefs to a slice `&[T]` and optionally also `&mut [T]`."],["CopyableFrameRange","A `FrameRange` that implements `Copy`"],["CopyablePageRange","A `PageRange` that implements `Copy`"],["EarlyIdentityMappedPages","The set of identity mappings that should be dropped before starting the first application."],["Frame","A `Frame` is a chunk of physical memory aligned to a [`PAGE_SIZE`] boundary."],["FrameRange","A range of [`Frame`]s that are contiguous in physical memory."],["Immutable","A marker type used to indicate that a [`BorrowedMappedPages`] or [`BorrowedSliceMappedPages`] is borrowed immutably."],["InitialMemoryMappings","Information returned after initialising the memory subsystem."],["MappedPages","Represents a contiguous range of virtual memory pages that are currently mapped.  A `MappedPages` object can only have a single range of contiguous pages, not multiple disjoint ranges. This does not guarantee that its pages are mapped to frames that are contiguous in physical memory."],["Mapper",""],["MemoryManagementInfo","This holds all the information for a `Task`’s memory mappings and address space (this is basically the equivalent of Linux’s mm_struct)"],["Mutable","A marker type used to indicate that a [`BorrowedMappedPages`] or [`BorrowedSliceMappedPages`] is borrowed mutably."],["Page","A `Page` is a chunk of virtual memory aligned to a [`PAGE_SIZE`] boundary."],["PageRange","A range of [`Page`]s that are contiguous in virtual memory."],["PageTable","A top-level root (P4) page table."],["PhysicalAddress","A physical memory address, which is a `usize` under the hood."],["PhysicalMemoryRegion","A region of physical memory."],["PteFlags","Common, architecture-independent flags for a page table entry (PTE) that define how a page is mapped."],["PteFlagsArch","Page table entry (PTE) flags on x86_64."],["PteFlagsX86_64","Page table entry (PTE) flags on x86_64."],["VirtualAddress","A virtual memory address, which is a `usize` under the hood."]],"trait":[["Mutability","A trait for parameterizing a [`BorrowedMappedPages`] or [`BorrowedSliceMappedPages`] as mutably or immutably borrowed."]],"type":[["MmiRef","A shareable reference to a `MemoryManagementInfo` struct wrapper in a lock."]]};