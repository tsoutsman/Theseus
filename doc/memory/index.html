<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate implements the virtual memory subsystem for Theseus, which is fairly robust and provides a unification between  arbitrarily mapped sections of memory and Rust’s lifetime system.  Originally based on Phil Opp’s blog_os. "><meta name="keywords" content="rust, rustlang, rust-lang, memory"><title>memory - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script defer src="../crates.js"></script><script defer src="../main.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../memory/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../memory/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Crate memory</a></h2><div class="sidebar-elems"><div class="block"><ul><li class="version">Version 0.1.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul></div><section><div class="block"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div></section></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../memory/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1">
                                <a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div>
                        </div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">memory</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/memory/lib.rs.html#1-273">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate implements the virtual memory subsystem for Theseus,
which is fairly robust and provides a unification between 
arbitrarily mapped sections of memory and Rust’s lifetime system. 
Originally based on Phil Opp’s blog_os. </p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.AggregatedSectionMemoryBounds.html" title="memory::AggregatedSectionMemoryBounds struct">AggregatedSectionMemoryBounds</a></div><div class="item-right docblock-short"><p>The address bounds and flags of the initial kernel sections that need mapping. </p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.AllocatedFrames.html" title="memory::AllocatedFrames struct">AllocatedFrames</a></div><div class="item-right docblock-short"><p>Represents a range of allocated <code>PhysicalAddress</code>es, specified in <code>Frame</code>s. </p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.AllocatedPages.html" title="memory::AllocatedPages struct">AllocatedPages</a></div><div class="item-right docblock-short"><p>Represents a range of allocated <code>VirtualAddress</code>es, specified in <code>Page</code>s. </p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.DeferredAllocAction.html" title="memory::DeferredAllocAction struct">DeferredAllocAction</a></div><div class="item-right docblock-short"><p>A series of pending actions related to page allocator bookkeeping,
which may result in heap allocation. </p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.EntryFlags.html" title="memory::EntryFlags struct">EntryFlags</a></div><div class="item-right docblock-short"><p>Page table entry flags on the x86_64 architecture. </p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Frame.html" title="memory::Frame struct">Frame</a></div><div class="item-right docblock-short"><p>A <code>Frame</code> is a chunk of <strong>physical</strong> memory aligned to a <a href="constant.PAGE_SIZE.html" title="PAGE_SIZE"><code>PAGE_SIZE</code></a> boundary.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.FrameRange.html" title="memory::FrameRange struct">FrameRange</a></div><div class="item-right docblock-short"><p>A range of <a href="struct.Frame.html" title="Frame"><code>Frame</code></a>s that are contiguous in physical memory.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.MappedPages.html" title="memory::MappedPages struct">MappedPages</a></div><div class="item-right docblock-short"><p>Represents a contiguous range of virtual memory pages that are currently mapped. 
A <code>MappedPages</code> object can only have a single range of contiguous pages, not multiple disjoint ranges.
This does not guarantee that its pages are mapped to frames that are contiguous in physical memory.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Mapper.html" title="memory::Mapper struct">Mapper</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.MemoryManagementInfo.html" title="memory::MemoryManagementInfo struct">MemoryManagementInfo</a></div><div class="item-right docblock-short"><p>This holds all the information for a <code>Task</code>’s memory mappings and address space
(this is basically the equivalent of Linux’s mm_struct)</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Page.html" title="memory::Page struct">Page</a></div><div class="item-right docblock-short"><p>A <code>Page</code> is a chunk of <strong>virtual</strong> memory aligned to a <a href="constant.PAGE_SIZE.html" title="PAGE_SIZE"><code>PAGE_SIZE</code></a> boundary.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.PageRange.html" title="memory::PageRange struct">PageRange</a></div><div class="item-right docblock-short"><p>A range of <a href="struct.Page.html" title="Page"><code>Page</code></a>s that are contiguous in virtual memory.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.PageTable.html" title="memory::PageTable struct">PageTable</a></div><div class="item-right docblock-short"><p>A top-level root (P4) page table.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.PageTableEntry.html" title="memory::PageTableEntry struct">PageTableEntry</a></div><div class="item-right docblock-short"><p>A page table entry, which is a <code>u64</code> value under the hood.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.PhysicalAddress.html" title="memory::PhysicalAddress struct">PhysicalAddress</a></div><div class="item-right docblock-short"><p>A physical memory address, which is a <code>usize</code> under the hood.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.PhysicalMemoryRegion.html" title="memory::PhysicalMemoryRegion struct">PhysicalMemoryRegion</a></div><div class="item-right docblock-short"><p>A region of physical memory.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.SectionMemoryBounds.html" title="memory::SectionMemoryBounds struct">SectionMemoryBounds</a></div><div class="item-right docblock-short"><p>The address bounds and mapping flags of a section’s memory region.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.TemporaryPage.html" title="memory::TemporaryPage struct">TemporaryPage</a></div><div class="item-right docblock-short"><p>A page that can be temporarily mapped to the recursive page table frame,
used for purposes of editing a top-level (P4) page table itself.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.UnmappedFrames.html" title="memory::UnmappedFrames struct">UnmappedFrames</a></div><div class="item-right docblock-short"><p>A range of frames that have been unmapped from a <code>PageTableEntry</code>
that previously mapped that frame exclusively (i.e., “owned it”).</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.VirtualAddress.html" title="memory::VirtualAddress struct">VirtualAddress</a></div><div class="item-right docblock-short"><p>A virtual memory address, which is a <code>usize</code> under the hood.</p>
</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.MemoryRegionType.html" title="memory::MemoryRegionType enum">MemoryRegionType</a></div><div class="item-right docblock-short"><p>Types of physical memory. See each variant’s documentation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.UnmapResult.html" title="memory::UnmapResult enum">UnmapResult</a></div><div class="item-right docblock-short"><p>The frames returned from the action of unmapping a page table entry.
See the <code>PageTableEntry::set_unmapped()</code> function.</p>
</div></div></div><h2 id="constants" class="small-section-header"><a href="#constants">Constants</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant.PAGE_SIZE.html" title="memory::PAGE_SIZE constant">PAGE_SIZE</a></div><div class="item-right docblock-short"><p>Page size is 4096 bytes, 4KiB pages.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="constant" href="constant.PAGE_TABLE_ENTRY_FRAME_MASK.html" title="memory::PAGE_TABLE_ENTRY_FRAME_MASK constant">PAGE_TABLE_ENTRY_FRAME_MASK</a></div><div class="item-right docblock-short"><p>A mask for the bits of a page table entry that contain the physical frame address.</p>
</div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.allocate_frames.html" title="memory::allocate_frames fn">allocate_frames</a></div><div class="item-right docblock-short"><p>Allocates the given number of frames with no constraints on the starting physical address.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.allocate_frames_at.html" title="memory::allocate_frames_at fn">allocate_frames_at</a></div><div class="item-right docblock-short"><p>Allocates the given number of frames starting at (inclusive of) the frame containing the given <code>PhysicalAddress</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.allocate_frames_by_bytes.html" title="memory::allocate_frames_by_bytes fn">allocate_frames_by_bytes</a></div><div class="item-right docblock-short"><p>Allocates frames with no constraints on the starting physical address, 
with a size given by the number of bytes. </p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.allocate_frames_by_bytes_at.html" title="memory::allocate_frames_by_bytes_at fn">allocate_frames_by_bytes_at</a></div><div class="item-right docblock-short"><p>Allocates frames starting at the given <code>PhysicalAddress</code> with a size given in number of bytes. </p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.allocate_frames_by_bytes_deferred.html" title="memory::allocate_frames_by_bytes_deferred fn">allocate_frames_by_bytes_deferred</a></div><div class="item-right docblock-short"><p>Similar to <a href="fn.allocate_frames_deferred.html"><code>allocated_frames_deferred()</code></a>,
but accepts a size value for the allocated frames in number of bytes instead of number of frames. </p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.allocate_frames_deferred.html" title="memory::allocate_frames_deferred fn">allocate_frames_deferred</a></div><div class="item-right docblock-short"><p>The core frame allocation routine that allocates the given number of physical frames,
optionally at the requested starting <code>PhysicalAddress</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.allocate_pages.html" title="memory::allocate_pages fn">allocate_pages</a></div><div class="item-right docblock-short"><p>Allocates the given number of pages with no constraints on the starting virtual address.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.allocate_pages_at.html" title="memory::allocate_pages_at fn">allocate_pages_at</a></div><div class="item-right docblock-short"><p>Allocates the given number of pages starting at (inclusive of) the page containing the given <code>VirtualAddress</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.allocate_pages_by_bytes.html" title="memory::allocate_pages_by_bytes fn">allocate_pages_by_bytes</a></div><div class="item-right docblock-short"><p>Allocates pages with no constraints on the starting virtual address, 
with a size given by the number of bytes. </p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.allocate_pages_by_bytes_at.html" title="memory::allocate_pages_by_bytes_at fn">allocate_pages_by_bytes_at</a></div><div class="item-right docblock-short"><p>Allocates pages starting at the given <code>VirtualAddress</code> with a size given in number of bytes. </p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.allocate_pages_by_bytes_deferred.html" title="memory::allocate_pages_by_bytes_deferred fn">allocate_pages_by_bytes_deferred</a></div><div class="item-right docblock-short"><p>Similar to <a href="fn.allocate_pages_deferred.html"><code>allocated_pages_deferred()</code></a>,
but accepts a size value for the allocated pages in number of bytes instead of number of pages. </p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.allocate_pages_deferred.html" title="memory::allocate_pages_deferred fn">allocate_pages_deferred</a></div><div class="item-right docblock-short"><p>The core page allocation routine that allocates the given number of virtual pages,
optionally at the requested starting <code>VirtualAddress</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.create_contiguous_mapping.html" title="memory::create_contiguous_mapping fn">create_contiguous_mapping</a></div><div class="item-right docblock-short"><p>A convenience function that creates a new memory mapping by allocating frames that are contiguous in physical memory.
If contiguous frames are not required, then see <a href="fn.create_mapping.html"><code>create_mapping()</code></a>.
Returns a tuple containing the new <code>MappedPages</code> and the starting PhysicalAddress of the first frame,
which is a convenient way to get the physical address without walking the page tables.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.create_mapping.html" title="memory::create_mapping fn">create_mapping</a></div><div class="item-right docblock-short"><p>A convenience function that creates a new memory mapping. The pages allocated are contiguous in memory but there’s
no guarantee that the frames they are mapped to are also contiguous in memory. If contiguous frames are required
then see <a href="fn.create_contiguous_mapping.html"><code>create_contiguous_mapping()</code></a>.
Returns the new <code>MappedPages.</code> </p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.get_current_p4.html" title="memory::get_current_p4 fn">get_current_p4</a></div><div class="item-right docblock-short"><p>Returns the current top-level (P4) root page table frame.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.get_kernel_mmi_ref.html" title="memory::get_kernel_mmi_ref fn">get_kernel_mmi_ref</a></div><div class="item-right docblock-short"><p>Returns a reference to the kernel’s <code>MemoryManagementInfo</code>, if initialized.
If not, it returns <code>None</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.init.html" title="memory::init fn">init</a></div><div class="item-right docblock-short"><p>Initializes the virtual memory management system.
Consumes the given BootInformation, because after the memory system is initialized,
the original BootInformation will be unmapped and inaccessible.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.init_post_heap.html" title="memory::init_post_heap fn">init_post_heap</a></div><div class="item-right docblock-short"><p>Finishes initializing the virtual memory management system after the heap is initialized and returns a MemoryManagementInfo instance,
which represents the initial (the kernel’s) address space. </p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.set_broadcast_tlb_shootdown_cb.html" title="memory::set_broadcast_tlb_shootdown_cb fn">set_broadcast_tlb_shootdown_cb</a></div><div class="item-right docblock-short"><p>Set the function callback that will be invoked every time a TLB shootdown is necessary,
i.e., during page table remapping and unmapping operations.</p>
</div></div></div><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.MmiRef.html" title="memory::MmiRef type">MmiRef</a></div><div class="item-right docblock-short"><p>A shareable reference to a <code>MemoryManagementInfo</code> struct wrapper in a lock.</p>
</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="memory" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.64.0-nightly (f8588549c 2022-07-18)" ></div>
</body></html>