<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate implements the main memory management subsystem for Theseus."><title>memory - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-f40c346f39d9abc1.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="memory" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.0-nightly (065a1f5df 2023-06-21)" data-search-js="search-95c92dd01058facf.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-190c35055d2a8300.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../memory/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../memory/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate memory</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.1.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#constants">Constants</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">memory</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/memory/lib.rs.html#1-317">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate implements the main memory management subsystem for Theseus.</p>
<p>The primary type of interest is <a href="struct.MappedPages.html" title="struct memory::MappedPages"><code>MappedPages</code></a>, which offers a robust
interface that unifies the usage of arbitrary memory regions
with that of Rust’s safe type system and lifetimes.</p>
<h3 id="acknowledgments"><a href="#acknowledgments">Acknowledgments</a></h3>
<p>Some of the internal page table management code was based on
Philipp Oppermann’s <a href="https://github.com/phil-opp/blog_os">blog_os</a>, but has since changed significantly.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.AllocatedFrames.html" title="struct memory::AllocatedFrames">AllocatedFrames</a></div><div class="desc docblock-short">Represents a range of allocated physical memory <a href="struct.Frame.html" title="struct memory::Frame"><code>Frame</code></a>s; derefs to <a href="struct.FrameRange.html" title="struct memory::FrameRange"><code>FrameRange</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.AllocatedPages.html" title="struct memory::AllocatedPages">AllocatedPages</a></div><div class="desc docblock-short">Represents a range of allocated <code>VirtualAddress</code>es, specified in <code>Page</code>s. </div></li><li><div class="item-name"><a class="struct" href="struct.BorrowedMappedPages.html" title="struct memory::BorrowedMappedPages">BorrowedMappedPages</a></div><div class="desc docblock-short">A borrowed <a href="struct.MappedPages.html" title="struct memory::MappedPages"><code>MappedPages</code></a> object that derefs to <code>&amp;T</code> and optionally also <code>&amp;mut T</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.BorrowedSliceMappedPages.html" title="struct memory::BorrowedSliceMappedPages">BorrowedSliceMappedPages</a></div><div class="desc docblock-short">A borrowed <a href="struct.MappedPages.html" title="struct memory::MappedPages"><code>MappedPages</code></a> object that derefs to a slice <code>&amp;[T]</code> and optionally also <code>&amp;mut [T]</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.CopyableFrameRange.html" title="struct memory::CopyableFrameRange">CopyableFrameRange</a></div><div class="desc docblock-short">A <code>FrameRange</code> that implements <code>Copy</code></div></li><li><div class="item-name"><a class="struct" href="struct.CopyablePageRange.html" title="struct memory::CopyablePageRange">CopyablePageRange</a></div><div class="desc docblock-short">A <code>PageRange</code> that implements <code>Copy</code></div></li><li><div class="item-name"><a class="struct" href="struct.EarlyIdentityMappedPages.html" title="struct memory::EarlyIdentityMappedPages">EarlyIdentityMappedPages</a></div><div class="desc docblock-short">The set of identity mappings that should be dropped before starting the first application.</div></li><li><div class="item-name"><a class="struct" href="struct.Frame.html" title="struct memory::Frame">Frame</a></div><div class="desc docblock-short">A <code>Frame</code> is a chunk of <strong>physical</strong> memory aligned to a <a href="constant.PAGE_SIZE.html" title="constant memory::PAGE_SIZE"><code>PAGE_SIZE</code></a> boundary.</div></li><li><div class="item-name"><a class="struct" href="struct.FrameRange.html" title="struct memory::FrameRange">FrameRange</a></div><div class="desc docblock-short">A range of <a href="struct.Frame.html" title="struct memory::Frame"><code>Frame</code></a>s that are contiguous in physical memory.</div></li><li><div class="item-name"><a class="struct" href="struct.Immutable.html" title="struct memory::Immutable">Immutable</a></div><div class="desc docblock-short">A marker type used to indicate that a <a href="struct.BorrowedMappedPages.html" title="struct memory::BorrowedMappedPages"><code>BorrowedMappedPages</code></a>
or <a href="struct.BorrowedSliceMappedPages.html" title="struct memory::BorrowedSliceMappedPages"><code>BorrowedSliceMappedPages</code></a> is borrowed immutably.</div></li><li><div class="item-name"><a class="struct" href="struct.InitialMemoryMappings.html" title="struct memory::InitialMemoryMappings">InitialMemoryMappings</a></div><div class="desc docblock-short">Information returned after initialising the memory subsystem.</div></li><li><div class="item-name"><a class="struct" href="struct.MappedPages.html" title="struct memory::MappedPages">MappedPages</a></div><div class="desc docblock-short">Represents a contiguous range of virtual memory pages that are currently mapped. 
A <code>MappedPages</code> object can only have a single range of contiguous pages, not multiple disjoint ranges.
This does not guarantee that its pages are mapped to frames that are contiguous in physical memory.</div></li><li><div class="item-name"><a class="struct" href="struct.Mapper.html" title="struct memory::Mapper">Mapper</a></div></li><li><div class="item-name"><a class="struct" href="struct.MemoryManagementInfo.html" title="struct memory::MemoryManagementInfo">MemoryManagementInfo</a></div><div class="desc docblock-short">This holds all the information for a <code>Task</code>’s memory mappings and address space
(this is basically the equivalent of Linux’s mm_struct)</div></li><li><div class="item-name"><a class="struct" href="struct.Mutable.html" title="struct memory::Mutable">Mutable</a></div><div class="desc docblock-short">A marker type used to indicate that a <a href="struct.BorrowedMappedPages.html" title="struct memory::BorrowedMappedPages"><code>BorrowedMappedPages</code></a>
or <a href="struct.BorrowedSliceMappedPages.html" title="struct memory::BorrowedSliceMappedPages"><code>BorrowedSliceMappedPages</code></a> is borrowed mutably.</div></li><li><div class="item-name"><a class="struct" href="struct.Page.html" title="struct memory::Page">Page</a></div><div class="desc docblock-short">A <code>Page</code> is a chunk of <strong>virtual</strong> memory aligned to a <a href="constant.PAGE_SIZE.html" title="constant memory::PAGE_SIZE"><code>PAGE_SIZE</code></a> boundary.</div></li><li><div class="item-name"><a class="struct" href="struct.PageRange.html" title="struct memory::PageRange">PageRange</a></div><div class="desc docblock-short">A range of <a href="struct.Page.html" title="struct memory::Page"><code>Page</code></a>s that are contiguous in virtual memory.</div></li><li><div class="item-name"><a class="struct" href="struct.PageTable.html" title="struct memory::PageTable">PageTable</a></div><div class="desc docblock-short">A top-level root (P4) page table.</div></li><li><div class="item-name"><a class="struct" href="struct.PhysicalAddress.html" title="struct memory::PhysicalAddress">PhysicalAddress</a></div><div class="desc docblock-short">A physical memory address, which is a <code>usize</code> under the hood.</div></li><li><div class="item-name"><a class="struct" href="struct.PteFlags.html" title="struct memory::PteFlags">PteFlags</a></div><div class="desc docblock-short">Common, architecture-independent flags for a page table entry (PTE)
that define how a page is mapped.</div></li><li><div class="item-name"><a class="struct" href="struct.PteFlagsArch.html" title="struct memory::PteFlagsArch">PteFlagsArch</a><span class="stab portability" title="Available on x86-64 only">x86-64</span></div><div class="desc docblock-short">Page table entry (PTE) flags on x86_64.</div></li><li><div class="item-name"><a class="struct" href="struct.PteFlagsX86_64.html" title="struct memory::PteFlagsX86_64">PteFlagsX86_64</a><span class="stab portability" title="Available on x86-64 only">x86-64</span></div><div class="desc docblock-short">Page table entry (PTE) flags on x86_64.</div></li><li><div class="item-name"><a class="struct" href="struct.VirtualAddress.html" title="struct memory::VirtualAddress">VirtualAddress</a></div><div class="desc docblock-short">A virtual memory address, which is a <code>usize</code> under the hood.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.AllocationRequest.html" title="enum memory::AllocationRequest">AllocationRequest</a></div><div class="desc docblock-short">Possible options when requested pages from the page allocator.</div></li></ul><h2 id="constants" class="small-section-header"><a href="#constants">Constants</a></h2><ul class="item-table"><li><div class="item-name"><a class="constant" href="constant.DMA_FLAGS.html" title="constant memory::DMA_FLAGS">DMA_FLAGS</a></div><div class="desc docblock-short">Mapping flags that can be used to map DMA (Direct Memory Access) memory.</div></li><li><div class="item-name"><a class="constant" href="constant.MMIO_FLAGS.html" title="constant memory::MMIO_FLAGS">MMIO_FLAGS</a></div><div class="desc docblock-short">Mapping flags that can be used to map MMIO registers.</div></li><li><div class="item-name"><a class="constant" href="constant.PAGE_SIZE.html" title="constant memory::PAGE_SIZE">PAGE_SIZE</a></div><div class="desc docblock-short">Page size is 4096 bytes, 4KiB pages.</div></li><li><div class="item-name"><a class="constant" href="constant.PTE_FRAME_MASK.html" title="constant memory::PTE_FRAME_MASK">PTE_FRAME_MASK</a></div><div class="desc docblock-short">A mask for the bits of a page table entry that contain the physical frame address.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Mutability.html" title="trait memory::Mutability">Mutability</a></div><div class="desc docblock-short">A trait for parameterizing a <a href="struct.BorrowedMappedPages.html" title="struct memory::BorrowedMappedPages"><code>BorrowedMappedPages</code></a>
or <a href="struct.BorrowedSliceMappedPages.html" title="struct memory::BorrowedSliceMappedPages"><code>BorrowedSliceMappedPages</code></a> as mutably or immutably borrowed.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.allocate_frames.html" title="fn memory::allocate_frames">allocate_frames</a></div><div class="desc docblock-short">Allocates the given number of frames with no constraints on the starting physical address.</div></li><li><div class="item-name"><a class="fn" href="fn.allocate_frames_at.html" title="fn memory::allocate_frames_at">allocate_frames_at</a></div><div class="desc docblock-short">Allocates the given number of frames starting at (inclusive of) the frame containing the given <code>PhysicalAddress</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.allocate_frames_by_bytes.html" title="fn memory::allocate_frames_by_bytes">allocate_frames_by_bytes</a></div><div class="desc docblock-short">Allocates frames with no constraints on the starting physical address, 
with a size given by the number of bytes. </div></li><li><div class="item-name"><a class="fn" href="fn.allocate_frames_by_bytes_at.html" title="fn memory::allocate_frames_by_bytes_at">allocate_frames_by_bytes_at</a></div><div class="desc docblock-short">Allocates frames starting at the given <code>PhysicalAddress</code> with a size given in number of bytes. </div></li><li><div class="item-name"><a class="fn" href="fn.allocate_pages.html" title="fn memory::allocate_pages">allocate_pages</a></div><div class="desc docblock-short">Allocates the given number of pages with no constraints on the starting virtual address.</div></li><li><div class="item-name"><a class="fn" href="fn.allocate_pages_at.html" title="fn memory::allocate_pages_at">allocate_pages_at</a></div><div class="desc docblock-short">Allocates the given number of pages starting at (inclusive of) the page containing the given <code>VirtualAddress</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.allocate_pages_by_bytes.html" title="fn memory::allocate_pages_by_bytes">allocate_pages_by_bytes</a></div><div class="desc docblock-short">Allocates pages with no constraints on the starting virtual address, 
with a size given by the number of bytes. </div></li><li><div class="item-name"><a class="fn" href="fn.allocate_pages_by_bytes_at.html" title="fn memory::allocate_pages_by_bytes_at">allocate_pages_by_bytes_at</a></div><div class="desc docblock-short">Allocates pages starting at the given <code>VirtualAddress</code> with a size given in number of bytes. </div></li><li><div class="item-name"><a class="fn" href="fn.allocate_pages_by_bytes_in_range.html" title="fn memory::allocate_pages_by_bytes_in_range">allocate_pages_by_bytes_in_range</a></div><div class="desc docblock-short">Allocates pages with a size given in number of bytes with the constraint that
they must be within the given inclusive <code>range</code> of pages.</div></li><li><div class="item-name"><a class="fn" href="fn.allocate_pages_in_range.html" title="fn memory::allocate_pages_in_range">allocate_pages_in_range</a></div><div class="desc docblock-short">Allocates the given number of pages with the constraint that
they must be within the given inclusive <code>range</code> of pages.</div></li><li><div class="item-name"><a class="fn" href="fn.create_contiguous_mapping.html" title="fn memory::create_contiguous_mapping">create_contiguous_mapping</a></div><div class="desc docblock-short">A convenience function that creates a new memory mapping by allocating frames that are contiguous in physical memory.
If contiguous frames are not required, then see <a href="fn.create_mapping.html"><code>create_mapping()</code></a>.
Returns a tuple containing the new <code>MappedPages</code> and the starting PhysicalAddress of the first frame,
which is a convenient way to get the physical address without walking the page tables.</div></li><li><div class="item-name"><a class="fn" href="fn.create_mapping.html" title="fn memory::create_mapping">create_mapping</a></div><div class="desc docblock-short">A convenience function that creates a new memory mapping. The pages allocated are contiguous in memory but there’s
no guarantee that the frames they are mapped to are also contiguous in memory. If contiguous frames are required
then see <a href="fn.create_contiguous_mapping.html"><code>create_contiguous_mapping()</code></a>.
Returns the new <code>MappedPages.</code> </div></li><li><div class="item-name"><a class="fn" href="fn.get_kernel_mmi_ref.html" title="fn memory::get_kernel_mmi_ref">get_kernel_mmi_ref</a></div><div class="desc docblock-short">Returns a reference to the kernel’s <code>MemoryManagementInfo</code>, if initialized.
If not, it returns <code>None</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.init.html" title="fn memory::init">init</a></div><div class="desc docblock-short">Initializes the virtual memory management system.
Consumes the given BootInformation, because after the memory system is initialized,
the original BootInformation will be unmapped and inaccessible.</div></li><li><div class="item-name"><a class="fn" href="fn.init_post_heap.html" title="fn memory::init_post_heap">init_post_heap</a></div><div class="desc docblock-short">Finishes initializing the memory management system after the heap is ready.</div></li><li><div class="item-name"><a class="fn" href="fn.map_frame_range.html" title="fn memory::map_frame_range">map_frame_range</a></div><div class="desc docblock-short">A convenience function that maps randomly-allocated pages to the given range of frames.</div></li><li><div class="item-name"><a class="fn" href="fn.set_broadcast_tlb_shootdown_cb.html" title="fn memory::set_broadcast_tlb_shootdown_cb">set_broadcast_tlb_shootdown_cb</a></div><div class="desc docblock-short">Set the function callback that will be invoked every time a TLB shootdown is necessary,
i.e., during page table remapping and unmapping operations.</div></li><li><div class="item-name"><a class="fn" href="fn.translate.html" title="fn memory::translate">translate</a></div><div class="desc docblock-short">A convenience function to translate the given virtual address into a
physical address using the currently-active page table.</div></li></ul><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.MmiRef.html" title="type memory::MmiRef">MmiRef</a></div><div class="desc docblock-short">A shareable reference to a <code>MemoryManagementInfo</code> struct wrapper in a lock.</div></li></ul></section></div></main></body></html>