window.SIDEBAR_ITEMS = {"enum":[["EventType","Used to select the event type to count. Event types are described in the Intel SDM 18.2.1 for PMU Version 1. The discriminant value for each event type is the value written to the event select register for a general purpose PMC."]],"fn":[["find_function_names_from_samples","Finds the corresponding function for each instruction pointer and calculates the percentage amount each function occured in the samples"],["handle_sample","This function is designed to be invoked from an interrupt handler  when a sampling interrupt has (or may have) occurred. "],["init","Initialization function that enables the PMU if one is available. We initialize the 3 fixed PMCs and general purpose PMCs. Calling this initialization function again on a core that has already been initialized will do nothing."],["print_samples","Simple function to print values from SampleResults in a form that the script “post-mortem pmu analysis.py” can parse. "],["reset_pmu","Frees all counters and make them available to be used. Essentially sets the PMU to its initial state."],["retrieve_samples","Returns the samples that were stored during sampling in the form of a SampleResults object.  If samples are not yet finished, forces them to stop.  "],["start_samples","Start interrupt process in order to take samples using the PMU.  It loads the starting value as such that an overflow will occur at “event_per_sample” events.  That overflow triggers an interrupt where information about the current running task is sampled."]],"mod":[["stat","This module implements the equivalent of “perf stat”. Currently only 7 events are recorded."]],"struct":[["Counter","A logical counter object to correspond to a physical PMC"],["SampleResults","Stores the instruction pointers and corresponding task IDs from the samples"]]};