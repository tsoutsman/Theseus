<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A list of `Task`s and their associated priority scheduler data that may be run on a given CPU core."><title>RunQueue in runqueue_priority - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-f40c346f39d9abc1.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="runqueue_priority" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.0-nightly (065a1f5df 2023-06-21)" data-search-js="search-95c92dd01058facf.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../static.files/storage-62ce34ea385b278a.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-190c35055d2a8300.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../runqueue_priority/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../runqueue_priority/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">RunQueue</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block"><li><a href="#method.add_task_to_any_runqueue">add_task_to_any_runqueue</a></li><li><a href="#method.add_task_to_specific_runqueue">add_task_to_specific_runqueue</a></li><li><a href="#method.get_least_busy_core">get_least_busy_core</a></li><li><a href="#method.get_runqueue">get_runqueue</a></li><li><a href="#method.idle_task">idle_task</a></li><li><a href="#method.init">init</a></li><li><a href="#method.remove_task">remove_task</a></li><li><a href="#method.remove_task_from_all">remove_task_from_all</a></li></ul><h3><a href="#deref-methods-BinaryHeap%3CPriorityTaskRef%3E">Methods from Deref&lt;Target=BinaryHeap&lt;PriorityTaskRef&gt;&gt;</a></h3><ul class="block"><li><a href="#method.allocator">allocator</a></li><li><a href="#method.append">append</a></li><li><a href="#method.as_slice">as_slice</a></li><li><a href="#method.capacity">capacity</a></li><li><a href="#method.clear">clear</a></li><li><a href="#method.drain">drain</a></li><li><a href="#method.drain_sorted">drain_sorted</a></li><li><a href="#method.is_empty">is_empty</a></li><li><a href="#method.iter">iter</a></li><li><a href="#method.len">len</a></li><li><a href="#method.peek">peek</a></li><li><a href="#method.peek_mut">peek_mut</a></li><li><a href="#method.pop">pop</a></li><li><a href="#method.push">push</a></li><li><a href="#method.reserve">reserve</a></li><li><a href="#method.reserve_exact">reserve_exact</a></li><li><a href="#method.retain">retain</a></li><li><a href="#method.shrink_to">shrink_to</a></li><li><a href="#method.shrink_to_fit">shrink_to_fit</a></li><li><a href="#method.try_reserve">try_reserve</a></li><li><a href="#method.try_reserve_exact">try_reserve_exact</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block"><li><a href="#impl-Debug-for-RunQueue">Debug</a></li><li><a href="#impl-Deref-for-RunQueue">Deref</a></li><li><a href="#impl-DerefMut-for-RunQueue">DerefMut</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block"><li><a href="#impl-RefUnwindSafe-for-RunQueue">!RefUnwindSafe</a></li><li><a href="#impl-UnwindSafe-for-RunQueue">!UnwindSafe</a></li><li><a href="#impl-Send-for-RunQueue">Send</a></li><li><a href="#impl-Sync-for-RunQueue">Sync</a></li><li><a href="#impl-Unpin-for-RunQueue">Unpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block"><li><a href="#impl-Any-for-RunQueue">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-RunQueue">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-RunQueue">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-RunQueue">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-RunQueue">Into&lt;U&gt;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-RunQueue">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-RunQueue">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In runqueue_priority</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="index.html">runqueue_priority</a>::<wbr><a class="struct" href="#">RunQueue</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/runqueue_priority/lib.rs.html#87-91">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct RunQueue { /* private fields */ }</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A list of <code>Task</code>s and their associated priority scheduler data that may be
run on a given CPU core.</p>
<p>In rate monotonic scheduling, tasks are sorted in order of increasing
periods. Thus, the <code>period</code> value acts as a form of task “priority”,
with higher priority (shorter period) tasks coming first.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-RunQueue" class="impl"><a class="srclink rightside" href="../src/runqueue_priority/lib.rs.html#107-246">source</a><a href="#impl-RunQueue" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.RunQueue.html" title="struct runqueue_priority::RunQueue">RunQueue</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.init" class="method"><a class="srclink rightside" href="../src/runqueue_priority/lib.rs.html#109-126">source</a><h4 class="code-header">pub fn <a href="#method.init" class="fn">init</a>(which_core: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>, idle_task: TaskRef) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.unit.html">()</a>, &amp;'static <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Creates a new <code>RunQueue</code> for the given core, which is an <code>apic_id</code></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_runqueue" class="method"><a class="srclink rightside" href="../src/runqueue_priority/lib.rs.html#129-131">source</a><h4 class="code-header">pub fn <a href="#method.get_runqueue" class="fn">get_runqueue</a>(
    which_core: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;'static PreemptionSafeRwLock&lt;<a class="struct" href="struct.RunQueue.html" title="struct runqueue_priority::RunQueue">RunQueue</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns <code>RunQueue</code> for the given core, which is an <code>apic_id</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_least_busy_core" class="method"><a class="srclink rightside" href="../src/runqueue_priority/lib.rs.html#135-137">source</a><h4 class="code-header">pub fn <a href="#method.get_least_busy_core" class="fn">get_least_busy_core</a>() -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the “least busy” core, which is currently very simple, based on
runqueue size.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_task_to_any_runqueue" class="method"><a class="srclink rightside" href="../src/runqueue_priority/lib.rs.html#162-168">source</a><h4 class="code-header">pub fn <a href="#method.add_task_to_any_runqueue" class="fn">add_task_to_any_runqueue</a>(task: TaskRef) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.unit.html">()</a>, &amp;'static <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Chooses the “least busy” core’s runqueue (based on simple
runqueue-size-based load balancing) and adds the given <code>Task</code>
reference to that core’s runqueue.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.add_task_to_specific_runqueue" class="method"><a class="srclink rightside" href="../src/runqueue_priority/lib.rs.html#172-180">source</a><h4 class="code-header">pub fn <a href="#method.add_task_to_specific_runqueue" class="fn">add_task_to_specific_runqueue</a>(
    which_core: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.u8.html">u8</a>,
    task: TaskRef
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.unit.html">()</a>, &amp;'static <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Convenience method that adds the given <code>Task</code> reference to given core’s
runqueue.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.remove_task" class="method"><a class="srclink rightside" href="../src/runqueue_priority/lib.rs.html#200-202">source</a><h4 class="code-header">pub fn <a href="#method.remove_task" class="fn">remove_task</a>(&amp;mut self, task: &amp;TaskRef) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.unit.html">()</a>, &amp;'static <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Removes a <code>TaskRef</code> from this RunQueue.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.remove_task_from_all" class="method"><a class="srclink rightside" href="../src/runqueue_priority/lib.rs.html#208-213">source</a><h4 class="code-header">pub fn <a href="#method.remove_task_from_all" class="fn">remove_task_from_all</a>(task: &amp;TaskRef) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.unit.html">()</a>, &amp;'static <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.str.html">str</a>&gt;</h4></section></summary><div class="docblock"><p>Removes a <code>TaskRef</code> from all <code>RunQueue</code>s that exist on the entire
system.</p>
<p>This is a brute force approach that iterates over all runqueues.</p>
</div></details><section id="method.idle_task" class="method"><a class="srclink rightside" href="../src/runqueue_priority/lib.rs.html#224-226">source</a><h4 class="code-header">pub fn <a href="#method.idle_task" class="fn">idle_task</a>(&amp;self) -&gt; &amp;TaskRef</h4></section></div></details></div><h2 id="deref-methods-BinaryHeap%3CPriorityTaskRef%3E" class="small-section-header"><span>Methods from <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/collections/binary_heap/struct.BinaryHeap.html" title="struct alloc::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;<a class="struct" href="struct.PriorityTaskRef.html" title="struct runqueue_priority::PriorityTaskRef">PriorityTaskRef</a>&gt;&gt;</span><a href="#deref-methods-BinaryHeap%3CPriorityTaskRef%3E" class="anchor">§</a></h2><div id="deref-methods-BinaryHeap%3CPriorityTaskRef%3E-1" class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.peek_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.12.0">1.12.0</span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/collections/binary_heap/mod.rs.html#540">source</a></span><h4 class="code-header">pub fn <a href="#method.peek_mut" class="fn">peek_mut</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/collections/binary_heap/struct.PeekMut.html" title="struct alloc::collections::binary_heap::PeekMut">PeekMut</a>&lt;'_, T, A&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns a mutable reference to the greatest item in the binary heap, or
<code>None</code> if it is empty.</p>
<p>Note: If the <code>PeekMut</code> value is leaked, some heap elements might get
leaked along with it, but the remaining elements will remain a valid
heap.</p>
<h5 id="examples"><a href="#examples">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::new();
<span class="macro">assert!</span>(heap.peek_mut().is_none());

heap.push(<span class="number">1</span>);
heap.push(<span class="number">5</span>);
heap.push(<span class="number">2</span>);
{
    <span class="kw">let </span><span class="kw-2">mut </span>val = heap.peek_mut().unwrap();
    <span class="kw-2">*</span>val = <span class="number">0</span>;
}
<span class="macro">assert_eq!</span>(heap.peek(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">2</span>));</code></pre></div>
<h5 id="time-complexity"><a href="#time-complexity">Time complexity</a></h5>
<p>If the item is modified then the worst case time complexity is <em>O</em>(log(<em>n</em>)),
otherwise it’s <em>O</em>(1).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.pop" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/collections/binary_heap/mod.rs.html#564">source</a></span><h4 class="code-header">pub fn <a href="#method.pop" class="fn">pop</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Removes the greatest item from the binary heap and returns it, or <code>None</code> if it
is empty.</p>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::from([<span class="number">1</span>, <span class="number">3</span>]);

<span class="macro">assert_eq!</span>(heap.pop(), <span class="prelude-val">Some</span>(<span class="number">3</span>));
<span class="macro">assert_eq!</span>(heap.pop(), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(heap.pop(), <span class="prelude-val">None</span>);</code></pre></div>
<h5 id="time-complexity-1"><a href="#time-complexity-1">Time complexity</a></h5>
<p>The worst case cost of <code>pop</code> on a heap containing <em>n</em> elements is <em>O</em>(log(<em>n</em>)).</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.push" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/collections/binary_heap/mod.rs.html#608">source</a></span><h4 class="code-header">pub fn <a href="#method.push" class="fn">push</a>(&amp;mut self, item: T)</h4></section></summary><div class="docblock"><p>Pushes an item onto the binary heap.</p>
<h5 id="examples-2"><a href="#examples-2">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::new();
heap.push(<span class="number">3</span>);
heap.push(<span class="number">5</span>);
heap.push(<span class="number">1</span>);

<span class="macro">assert_eq!</span>(heap.len(), <span class="number">3</span>);
<span class="macro">assert_eq!</span>(heap.peek(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">5</span>));</code></pre></div>
<h5 id="time-complexity-2"><a href="#time-complexity-2">Time complexity</a></h5>
<p>The expected cost of <code>push</code>, averaged over every possible ordering of
the elements being pushed, and over a sufficiently large number of
pushes, is <em>O</em>(1). This is the most meaningful cost metric when pushing
elements that are <em>not</em> already in any sorted pattern.</p>
<p>The time complexity degrades if elements are pushed in predominantly
ascending order. In the worst case, elements are pushed in ascending
sorted order and the amortized cost per push is <em>O</em>(log(<em>n</em>)) against a heap
containing <em>n</em> elements.</p>
<p>The worst case cost of a <em>single</em> call to <code>push</code> is <em>O</em>(<em>n</em>). The worst case
occurs when capacity is exhausted and needs a resize. The resize cost
has been amortized in the previous figures.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.append" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.11.0">1.11.0</span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/collections/binary_heap/mod.rs.html#854">source</a></span><h4 class="code-header">pub fn <a href="#method.append" class="fn">append</a>(&amp;mut self, other: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/collections/binary_heap/struct.BinaryHeap.html" title="struct alloc::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T, A&gt;)</h4></section></summary><div class="docblock"><p>Moves all the elements of <code>other</code> into <code>self</code>, leaving <code>other</code> empty.</p>
<h5 id="examples-3"><a href="#examples-3">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;

<span class="kw">let </span><span class="kw-2">mut </span>a = BinaryHeap::from([-<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]);
<span class="kw">let </span><span class="kw-2">mut </span>b = BinaryHeap::from([-<span class="number">20</span>, <span class="number">5</span>, <span class="number">43</span>]);

a.append(<span class="kw-2">&amp;mut </span>b);

<span class="macro">assert_eq!</span>(a.into_sorted_vec(), [-<span class="number">20</span>, -<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">43</span>]);
<span class="macro">assert!</span>(b.is_empty());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.drain_sorted" class="method"><a class="srclink rightside" href="https://doc.rust-lang.org/nightly/src/alloc/collections/binary_heap/mod.rs.html#893">source</a><h4 class="code-header">pub fn <a href="#method.drain_sorted" class="fn">drain_sorted</a>(&amp;mut self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/collections/binary_heap/struct.DrainSorted.html" title="struct alloc::collections::binary_heap::DrainSorted">DrainSorted</a>&lt;'_, T, A&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>binary_heap_drain_sorted</code>)</span></div></span></summary><div class="docblock"><p>Clears the binary heap, returning an iterator over the removed elements
in heap order. If the iterator is dropped before being fully consumed,
it drops the remaining elements in heap order.</p>
<p>The returned iterator keeps a mutable borrow on the heap to optimize
its implementation.</p>
<p>Note:</p>
<ul>
<li><code>.drain_sorted()</code> is <em>O</em>(<em>n</em> * log(<em>n</em>)); much slower than <code>.drain()</code>.
You should use the latter for most cases.</li>
</ul>
<h5 id="examples-4"><a href="#examples-4">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(binary_heap_drain_sorted)]
</span><span class="kw">use </span>std::collections::BinaryHeap;

<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);
<span class="macro">assert_eq!</span>(heap.len(), <span class="number">5</span>);

drop(heap.drain_sorted()); <span class="comment">// removes all elements in heap order
</span><span class="macro">assert_eq!</span>(heap.len(), <span class="number">0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.retain" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.70.0">1.70.0</span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/collections/binary_heap/mod.rs.html#916-918">source</a></span><h4 class="code-header">pub fn <a href="#method.retain" class="fn">retain</a>&lt;F&gt;(&amp;mut self, f: F)<span class="where fmt-newline">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.reference.html">&amp;T</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.bool.html">bool</a>,</span></h4></section></summary><div class="docblock"><p>Retains only the elements specified by the predicate.</p>
<p>In other words, remove all elements <code>e</code> for which <code>f(&amp;e)</code> returns
<code>false</code>. The elements are visited in unsorted (and unspecified) order.</p>
<h5 id="examples-5"><a href="#examples-5">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;

<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::from([-<span class="number">10</span>, -<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">13</span>]);

heap.retain(|x| x % <span class="number">2 </span>== <span class="number">0</span>); <span class="comment">// only keep even numbers

</span><span class="macro">assert_eq!</span>(heap.into_sorted_vec(), [-<span class="number">10</span>, <span class="number">2</span>, <span class="number">4</span>])</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.iter" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/collections/binary_heap/mod.rs.html#954">source</a></span><h4 class="code-header">pub fn <a href="#method.iter" class="fn">iter</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/collections/binary_heap/struct.Iter.html" title="struct alloc::collections::binary_heap::Iter">Iter</a>&lt;'_, T&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator visiting all values in the underlying vector, in
arbitrary order.</p>
<h5 id="examples-6"><a href="#examples-6">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span>heap = BinaryHeap::from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);

<span class="comment">// Print 1, 2, 3, 4 in arbitrary order
</span><span class="kw">for </span>x <span class="kw">in </span>heap.iter() {
    <span class="macro">println!</span>(<span class="string">&quot;{x}&quot;</span>);
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.peek" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/collections/binary_heap/mod.rs.html#1000">source</a></span><h4 class="code-header">pub fn <a href="#method.peek" class="fn">peek</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.reference.html">&amp;T</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the greatest item in the binary heap, or <code>None</code> if it is empty.</p>
<h5 id="examples-7"><a href="#examples-7">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::new();
<span class="macro">assert_eq!</span>(heap.peek(), <span class="prelude-val">None</span>);

heap.push(<span class="number">1</span>);
heap.push(<span class="number">5</span>);
heap.push(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(heap.peek(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">5</span>));
</code></pre></div>
<h5 id="time-complexity-3"><a href="#time-complexity-3">Time complexity</a></h5>
<p>Cost is <em>O</em>(1) in the worst case.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.capacity" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/collections/binary_heap/mod.rs.html#1018">source</a></span><h4 class="code-header">pub fn <a href="#method.capacity" class="fn">capacity</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of elements the binary heap can hold without reallocating.</p>
<h5 id="examples-8"><a href="#examples-8">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::with_capacity(<span class="number">100</span>);
<span class="macro">assert!</span>(heap.capacity() &gt;= <span class="number">100</span>);
heap.push(<span class="number">4</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reserve_exact" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/collections/binary_heap/mod.rs.html#1049">source</a></span><h4 class="code-header">pub fn <a href="#method.reserve_exact" class="fn">reserve_exact</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Reserves the minimum capacity for at least <code>additional</code> elements more than
the current length. Unlike <a href="https://doc.rust-lang.org/nightly/alloc/collections/binary_heap/struct.BinaryHeap.html#method.reserve" title="method alloc::collections::binary_heap::BinaryHeap::reserve"><code>reserve</code></a>, this will not
deliberately over-allocate to speculatively avoid frequent allocations.
After calling <code>reserve_exact</code>, capacity will be greater than or equal to
<code>self.len() + additional</code>. Does nothing if the capacity is already
sufficient.</p>
<h5 id="panics"><a href="#panics">Panics</a></h5>
<p>Panics if the new capacity overflows <a href="https://doc.rust-lang.org/nightly/core/primitive.usize.html" title="primitive usize"><code>usize</code></a>.</p>
<h5 id="examples-9"><a href="#examples-9">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::new();
heap.reserve_exact(<span class="number">100</span>);
<span class="macro">assert!</span>(heap.capacity() &gt;= <span class="number">100</span>);
heap.push(<span class="number">4</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.reserve" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/collections/binary_heap/mod.rs.html#1075">source</a></span><h4 class="code-header">pub fn <a href="#method.reserve" class="fn">reserve</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Reserves capacity for at least <code>additional</code> elements more than the
current length. The allocator may reserve more space to speculatively
avoid frequent allocations. After calling <code>reserve</code>,
capacity will be greater than or equal to <code>self.len() + additional</code>.
Does nothing if capacity is already sufficient.</p>
<h5 id="panics-1"><a href="#panics-1">Panics</a></h5>
<p>Panics if the new capacity overflows <a href="https://doc.rust-lang.org/nightly/core/primitive.usize.html" title="primitive usize"><code>usize</code></a>.</p>
<h5 id="examples-10"><a href="#examples-10">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::new();
heap.reserve(<span class="number">100</span>);
<span class="macro">assert!</span>(heap.capacity() &gt;= <span class="number">100</span>);
heap.push(<span class="number">4</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_reserve_exact" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.63.0">1.63.0</span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/collections/binary_heap/mod.rs.html#1117">source</a></span><h4 class="code-header">pub fn <a href="#method.try_reserve_exact" class="fn">try_reserve_exact</a>(
    &amp;mut self,
    additional: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/collections/struct.TryReserveError.html" title="struct alloc::collections::TryReserveError">TryReserveError</a>&gt;</h4></section></summary><div class="docblock"><p>Tries to reserve the minimum capacity for at least <code>additional</code> elements
more than the current length. Unlike <a href="https://doc.rust-lang.org/nightly/alloc/collections/binary_heap/struct.BinaryHeap.html#method.try_reserve" title="method alloc::collections::binary_heap::BinaryHeap::try_reserve"><code>try_reserve</code></a>, this will not
deliberately over-allocate to speculatively avoid frequent allocations.
After calling <code>try_reserve_exact</code>, capacity will be greater than or
equal to <code>self.len() + additional</code> if it returns <code>Ok(())</code>.
Does nothing if the capacity is already sufficient.</p>
<p>Note that the allocator may give the collection more space than it
requests. Therefore, capacity can not be relied upon to be precisely
minimal. Prefer <a href="https://doc.rust-lang.org/nightly/alloc/collections/binary_heap/struct.BinaryHeap.html#method.try_reserve" title="method alloc::collections::binary_heap::BinaryHeap::try_reserve"><code>try_reserve</code></a> if future insertions are expected.</p>
<h5 id="errors"><a href="#errors">Errors</a></h5>
<p>If the capacity overflows, or the allocator reports a failure, then an error
is returned.</p>
<h5 id="examples-11"><a href="#examples-11">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">use </span>std::collections::TryReserveError;

<span class="kw">fn </span>find_max_slow(data: <span class="kw-2">&amp;</span>[u32]) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="prelude-ty">Option</span>&lt;u32&gt;, TryReserveError&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::new();

    <span class="comment">// Pre-reserve the memory, exiting if we can&#39;t
    </span>heap.try_reserve_exact(data.len())<span class="question-mark">?</span>;

    <span class="comment">// Now we know this can&#39;t OOM in the middle of our complex work
    </span>heap.extend(data.iter());

    <span class="prelude-val">Ok</span>(heap.pop())
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_reserve" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.63.0">1.63.0</span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/collections/binary_heap/mod.rs.html#1153">source</a></span><h4 class="code-header">pub fn <a href="#method.try_reserve" class="fn">try_reserve</a>(&amp;mut self, additional: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/collections/struct.TryReserveError.html" title="struct alloc::collections::TryReserveError">TryReserveError</a>&gt;</h4></section></summary><div class="docblock"><p>Tries to reserve capacity for at least <code>additional</code> elements more than the
current length. The allocator may reserve more space to speculatively
avoid frequent allocations. After calling <code>try_reserve</code>, capacity will be
greater than or equal to <code>self.len() + additional</code> if it returns
<code>Ok(())</code>. Does nothing if capacity is already sufficient. This method
preserves the contents even if an error occurs.</p>
<h5 id="errors-1"><a href="#errors-1">Errors</a></h5>
<p>If the capacity overflows, or the allocator reports a failure, then an error
is returned.</p>
<h5 id="examples-12"><a href="#examples-12">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">use </span>std::collections::TryReserveError;

<span class="kw">fn </span>find_max_slow(data: <span class="kw-2">&amp;</span>[u32]) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="prelude-ty">Option</span>&lt;u32&gt;, TryReserveError&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::new();

    <span class="comment">// Pre-reserve the memory, exiting if we can&#39;t
    </span>heap.try_reserve(data.len())<span class="question-mark">?</span>;

    <span class="comment">// Now we know this can&#39;t OOM in the middle of our complex work
    </span>heap.extend(data.iter());

    <span class="prelude-val">Ok</span>(heap.pop())
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.shrink_to_fit" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/collections/binary_heap/mod.rs.html#1172">source</a></span><h4 class="code-header">pub fn <a href="#method.shrink_to_fit" class="fn">shrink_to_fit</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Discards as much additional capacity as possible.</p>
<h5 id="examples-13"><a href="#examples-13">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap: BinaryHeap&lt;i32&gt; = BinaryHeap::with_capacity(<span class="number">100</span>);

<span class="macro">assert!</span>(heap.capacity() &gt;= <span class="number">100</span>);
heap.shrink_to_fit();
<span class="macro">assert!</span>(heap.capacity() == <span class="number">0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.shrink_to" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.56.0">1.56.0</span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/collections/binary_heap/mod.rs.html#1195">source</a></span><h4 class="code-header">pub fn <a href="#method.shrink_to" class="fn">shrink_to</a>(&amp;mut self, min_capacity: <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Discards capacity with a lower bound.</p>
<p>The capacity will remain at least as large as both the length
and the supplied value.</p>
<p>If the current capacity is less than the lower limit, this is a no-op.</p>
<h5 id="examples-14"><a href="#examples-14">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap: BinaryHeap&lt;i32&gt; = BinaryHeap::with_capacity(<span class="number">100</span>);

<span class="macro">assert!</span>(heap.capacity() &gt;= <span class="number">100</span>);
heap.shrink_to(<span class="number">10</span>);
<span class="macro">assert!</span>(heap.capacity() &gt;= <span class="number">10</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_slice" class="method"><a class="srclink rightside" href="https://doc.rust-lang.org/nightly/src/alloc/collections/binary_heap/mod.rs.html#1217">source</a><h4 class="code-header">pub fn <a href="#method.as_slice" class="fn">as_slice</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.slice.html">[T]</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>binary_heap_as_slice</code>)</span></div></span></summary><div class="docblock"><p>Returns a slice of all values in the underlying vector, in arbitrary
order.</p>
<h5 id="examples-15"><a href="#examples-15">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(binary_heap_as_slice)]
</span><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">use </span>std::io::{<span class="self">self</span>, Write};

<span class="kw">let </span>heap = BinaryHeap::from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]);

io::sink().write(heap.as_slice()).unwrap();</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.allocator" class="method"><a class="srclink rightside" href="https://doc.rust-lang.org/nightly/src/alloc/collections/binary_heap/mod.rs.html#1247">source</a><h4 class="code-header">pub fn <a href="#method.allocator" class="fn">allocator</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.reference.html">&amp;A</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>allocator_api</code>)</span></div></span></summary><div class="docblock"><p>Returns a reference to the underlying allocator.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.len" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/collections/binary_heap/mod.rs.html#1265">source</a></span><h4 class="code-header">pub fn <a href="#method.len" class="fn">len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the length of the binary heap.</p>
<h5 id="examples-16"><a href="#examples-16">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span>heap = BinaryHeap::from([<span class="number">1</span>, <span class="number">3</span>]);

<span class="macro">assert_eq!</span>(heap.len(), <span class="number">2</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_empty" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/collections/binary_heap/mod.rs.html#1289">source</a></span><h4 class="code-header">pub fn <a href="#method.is_empty" class="fn">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if the binary heap is empty.</p>
<h5 id="examples-17"><a href="#examples-17">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::new();

<span class="macro">assert!</span>(heap.is_empty());

heap.push(<span class="number">3</span>);
heap.push(<span class="number">5</span>);
heap.push(<span class="number">1</span>);

<span class="macro">assert!</span>(!heap.is_empty());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.drain" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.6.0">1.6.0</span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/collections/binary_heap/mod.rs.html#1318">source</a></span><h4 class="code-header">pub fn <a href="#method.drain" class="fn">drain</a>(&amp;mut self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/collections/binary_heap/struct.Drain.html" title="struct alloc::collections::binary_heap::Drain">Drain</a>&lt;'_, T, A&gt;</h4></section></summary><div class="docblock"><p>Clears the binary heap, returning an iterator over the removed elements
in arbitrary order. If the iterator is dropped before being fully
consumed, it drops the remaining elements in arbitrary order.</p>
<p>The returned iterator keeps a mutable borrow on the heap to optimize
its implementation.</p>
<h5 id="examples-18"><a href="#examples-18">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::from([<span class="number">1</span>, <span class="number">3</span>]);

<span class="macro">assert!</span>(!heap.is_empty());

<span class="kw">for </span>x <span class="kw">in </span>heap.drain() {
    <span class="macro">println!</span>(<span class="string">&quot;{x}&quot;</span>);
}

<span class="macro">assert!</span>(heap.is_empty());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.clear" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/collections/binary_heap/mod.rs.html#1339">source</a></span><h4 class="code-header">pub fn <a href="#method.clear" class="fn">clear</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Drops all items from the binary heap.</p>
<h5 id="examples-19"><a href="#examples-19">Examples</a></h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::collections::BinaryHeap;
<span class="kw">let </span><span class="kw-2">mut </span>heap = BinaryHeap::from([<span class="number">1</span>, <span class="number">3</span>]);

<span class="macro">assert!</span>(!heap.is_empty());

heap.clear();

<span class="macro">assert!</span>(heap.is_empty());</code></pre></div>
</div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-RunQueue" class="impl"><a class="srclink rightside" href="../src/runqueue_priority/lib.rs.html#86">source</a><a href="#impl-Debug-for-RunQueue" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.RunQueue.html" title="struct runqueue_priority::RunQueue">RunQueue</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="srclink rightside" href="../src/runqueue_priority/lib.rs.html#86">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Deref-for-RunQueue" class="impl"><a class="srclink rightside" href="../src/runqueue_priority/lib.rs.html#93-99">source</a><a href="#impl-Deref-for-RunQueue" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a> for <a class="struct" href="struct.RunQueue.html" title="struct runqueue_priority::RunQueue">RunQueue</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Target" class="associatedtype trait-impl"><a href="#associatedtype.Target" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target" class="associatedtype">Target</a> = <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/collections/binary_heap/struct.BinaryHeap.html" title="struct alloc::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;<a class="struct" href="struct.PriorityTaskRef.html" title="struct runqueue_priority::PriorityTaskRef">PriorityTaskRef</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/alloc/struct.Global.html" title="struct alloc::alloc::Global">Global</a>&gt;</h4></section></summary><div class='docblock'>The resulting type after dereferencing.</div></details><details class="toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl"><a class="srclink rightside" href="../src/runqueue_priority/lib.rs.html#96-98">source</a><a href="#method.deref" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#tymethod.deref" class="fn">deref</a>(&amp;self) -&gt; &amp;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/collections/binary_heap/struct.BinaryHeap.html" title="struct alloc::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;<a class="struct" href="struct.PriorityTaskRef.html" title="struct runqueue_priority::PriorityTaskRef">PriorityTaskRef</a>&gt;</h4></section></summary><div class='docblock'>Dereferences the value.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-DerefMut-for-RunQueue" class="impl"><a class="srclink rightside" href="../src/runqueue_priority/lib.rs.html#101-105">source</a><a href="#impl-DerefMut-for-RunQueue" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a> for <a class="struct" href="struct.RunQueue.html" title="struct runqueue_priority::RunQueue">RunQueue</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.deref_mut" class="method trait-impl"><a class="srclink rightside" href="../src/runqueue_priority/lib.rs.html#102-104">source</a><a href="#method.deref_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.DerefMut.html#tymethod.deref_mut" class="fn">deref_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/collections/binary_heap/struct.BinaryHeap.html" title="struct alloc::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;<a class="struct" href="struct.PriorityTaskRef.html" title="struct runqueue_priority::PriorityTaskRef">PriorityTaskRef</a>&gt;</h4></section></summary><div class='docblock'>Mutably dereferences the value.</div></details></div></details></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-RunQueue" class="impl"><a href="#impl-RefUnwindSafe-for-RunQueue" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.RunQueue.html" title="struct runqueue_priority::RunQueue">RunQueue</a></h3></section><section id="impl-Send-for-RunQueue" class="impl"><a href="#impl-Send-for-RunQueue" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.RunQueue.html" title="struct runqueue_priority::RunQueue">RunQueue</a></h3></section><section id="impl-Sync-for-RunQueue" class="impl"><a href="#impl-Sync-for-RunQueue" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.RunQueue.html" title="struct runqueue_priority::RunQueue">RunQueue</a></h3></section><section id="impl-Unpin-for-RunQueue" class="impl"><a href="#impl-Unpin-for-RunQueue" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.RunQueue.html" title="struct runqueue_priority::RunQueue">RunQueue</a></h3></section><section id="impl-UnwindSafe-for-RunQueue" class="impl"><a href="#impl-UnwindSafe-for-RunQueue" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.RunQueue.html" title="struct runqueue_priority::RunQueue">RunQueue</a></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-RunQueue" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#201">source</a><a href="#impl-Any-for-RunQueue" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<span class="where fmt-newline">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#202">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-RunQueue" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-RunQueue" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-RunQueue" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-RunQueue" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<span class="where fmt-newline">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/core/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-RunQueue" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#722">source</a><a href="#impl-From%3CT%3E-for-RunQueue" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#725">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-RunQueue" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#706">source</a><a href="#impl-Into%3CU%3E-for-RunQueue" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#715">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-RunQueue" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#762">source</a><a href="#impl-TryFrom%3CU%3E-for-RunQueue" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#769">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-RunQueue" class="impl"><a class="srclink rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#747">source</a><a href="#impl-TryInto%3CU%3E-for-RunQueue" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<span class="where fmt-newline">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="srclink rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#754">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>