<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="DFQ is a decoupled, fault-tolerant, multi-producer single-consumer queue. DFQ is compatible with `no_std` and is interrupt-safe by being entirely lock-free and mostly wait-free."><title>dfqueue - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-f40c346f39d9abc1.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="dfqueue" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.0-nightly (065a1f5df 2023-06-21)" data-search-js="search-95c92dd01058facf.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-190c35055d2a8300.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../dfqueue/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../dfqueue/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate dfqueue</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.1.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">dfqueue</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/dfqueue/lib.rs.html#1-673">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>DFQ is a decoupled, fault-tolerant, multi-producer single-consumer queue.
DFQ is compatible with <code>no_std</code> and is interrupt-safe by being entirely lock-free and mostly wait-free.</p>
<p>DFQ accepts immutable data items only and does not allow the consumer
to immediately remove (pop) or modify the items in the queue.
In a transactional fashion, the consumer must call <a href="struct.PeekedData.html#method.mark_completed" title="method dfqueue::PeekedData::mark_completed"><code>mark_completed</code></a>
on a queued item to indicate that that item can be safely removed from the queue. 
Because the original producer that enqueued that item retains a reference to that item,
it is then safe for any entity (any producer or the consumer) to remove it from the queue. 
Currently, the consumer simply removes completed items from the queue on the next occasion 
of a conumser method like <code>peek()</code>.</p>
<p>Each producer retains ownership of the data items it queues, and only those items. 
Thus, a producer is able to query the status of that item’s handling by the consumer, 
to see if it is still on the queue or if something has gone wrong and it has failed. 
If a failure has occurred, that producer can enqueue that item again, 
but of course its original position in the queue will be lost. </p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="mpsc_queue/index.html" title="mod dfqueue::mpsc_queue">mpsc_queue</a></div><div class="desc docblock-short">Ported from Rust’s std::sync::mpsc::Queue.</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.DFQueue.html" title="struct dfqueue::DFQueue">DFQueue</a></div><div class="desc docblock-short">The actual queue, an opaque type that cannot be used directly. 
The user must use <code>DFQueueConsumer</code> and <code>DFQueueProducer</code>. </div></li><li><div class="item-name"><a class="struct" href="struct.DFQueueConsumer.html" title="struct dfqueue::DFQueueConsumer">DFQueueConsumer</a></div><div class="desc docblock-short">A consumer that can process (peek into) elements in a DFQueue, but not actually remove them.
Do not wrap this in an Arc or Mutex, the queue it is already protected by those on the interior. </div></li><li><div class="item-name"><a class="struct" href="struct.DFQueueProducer.html" title="struct dfqueue::DFQueueProducer">DFQueueProducer</a></div><div class="desc docblock-short">A producer that can enqueue elements into a DFQueue.
Do not wrap this in an Arc or Mutex, the queue it is already protected by those on the interior. </div></li><li><div class="item-name"><a class="struct" href="struct.PeekedData.html" title="struct dfqueue::PeekedData">PeekedData</a></div><div class="desc docblock-short">A wrapper around data in the queue that allows a DFQueueConsumer 
to access the data and mark the queued item as completed. 
Automatically Derefs to the inner type <code>&amp;T</code>, just like Arc does. </div></li><li><div class="item-name"><a class="struct" href="struct.QueuedData.html" title="struct dfqueue::QueuedData">QueuedData</a></div><div class="desc docblock-short">A special reference type that wraps a data item that has been queued. 
This is returned to a producer thread (the user of a DFQueueProducer)
when enqueuing an item onto the queue so that the producer 
can retain a reference to it in the case of failure.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.PeekResult.html" title="enum dfqueue::PeekResult">PeekResult</a></div><div class="desc docblock-short">A result of the <code>peek</code> function.</div></li></ul></section></div></main></body></html>