<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Abstractions for deferred interrupt tasks, a companion to regular interrupt handlers."><title>deferred_interrupt_tasks - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-f40c346f39d9abc1.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="deferred_interrupt_tasks" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.0-nightly (065a1f5df 2023-06-21)" data-search-js="search-95c92dd01058facf.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-190c35055d2a8300.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../deferred_interrupt_tasks/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../deferred_interrupt_tasks/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate deferred_interrupt_tasks</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.1.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">deferred_interrupt_tasks</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/deferred_interrupt_tasks/lib.rs.html#1-177">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Abstractions for deferred interrupt tasks, a companion to regular interrupt handlers.</p>
<p>Deferred interrupt tasks are similar to the concept of “top half” and “bottom half”
interrupt handlers in other OSes, in which the top half is the short, latency-sensitive
function that runs immediately when the interrupt request is serviced,
while the bottom half is the more complex function that runs in a deferred manner
to handle longer operations.
Other terminology is often used, including “first-level” and
“second-level” interrupt handlers, or “hard” and “soft” interrupt handlers.</p>
<p>That being said, this implementation of deferred interrupt tasks
differs from both tasklets and workqueues in Linux.
We also do not use the “top half” or “bottom half” terminology
because it is confusing and difficult to remember which is which.
Instead, we refer to the first latency-sensitive part as the
<em>interrupt handler</em> and the second later part as the <em>deferred task</em>.
The “interrupt handler” runs immediately (in a synchronous fashion) 
when the interrupt occurs, while the deferred task runs asynchronously
at some time in the future, ideally as soon as possible.</p>
<p>The general idea is that an interrupt handler should be short
and do the minimum amount of work possible in order to keep 
the system responsive, because all (or most) other interrupts
are typically disabled while the interrupt handler executes to completion.
Thus, most of the work should be deferred until later, such that the
interrupt handler itself only does a couple of quick things:</p>
<ul>
<li>Notifies the deferred task that work is ready to be done,
optionally providing details about what work it needs to do,</li>
<li>Acknowledges the interrupt such that the hardware knows it was handled.</li>
</ul>
<p>The deferred task is tied directly to a single interrupt handler in a 1-to-1 manner
at the time of creation, which occurs in <a href="fn.register_interrupt_handler.html" title="fn deferred_interrupt_tasks::register_interrupt_handler"><code>register_interrupt_handler()</code></a>.
Therefore, it is both efficient and easy to use. 
In the simplest of cases, such as a serial port device, the interrupt handler
only needs to mark the deferred task as unblocked (runnable)
and then acknowledge the interrupt. 
No other data exchange is needed between the interrupt handler and the 
deferred task.
For more complicated cases, the interrupt handler may need to do a minimal
amount of bookkeeping tasks (such as advancing a ringbuffer index)
and potentially send some information about what the deferred task should do.
It is typically best to use a lock-free queue or an interrupt-safe mutex
to share such information between the interrupt handler and deferred task.</p>
</div></details><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.InterruptRegistrationError.html" title="enum deferred_interrupt_tasks::InterruptRegistrationError">InterruptRegistrationError</a></div><div class="desc docblock-short">The errors that may occur in <a href="fn.register_interrupt_handler.html" title="fn deferred_interrupt_tasks::register_interrupt_handler"><code>register_interrupt_handler()</code></a>.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.register_interrupt_handler.html" title="fn deferred_interrupt_tasks::register_interrupt_handler">register_interrupt_handler</a></div><div class="desc docblock-short">Registers an interrupt handler and spawns a companion “deferred task” 
that asynchronously handles the longer-running operations related to that interrupt.</div></li></ul></section></div></main></body></html>